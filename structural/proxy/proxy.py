# Главное:
#    Паттерн Proxy позволяет подставлять вместо реальных объектов специальные объекты-заместители. Эти объекты
#    контролируют доступ к реальному объекту, перехватывая вызовы к нему и позволяя сделать что-то до или после
#    передачи вызова оригиналу.
# Применение:
#    1. Ленивая инициализация (виртуальный прокси). Когда есть тяжёлый объект, грузящий данные из файловой системы или
#    базы данных. Можно сэкономить ресурсы и создать объект тогда, когда он действительно понадобится.
#    2. Защита доступа (защищающий прокси). Когда есть разные типы пользователей, и нужно защищать объект от
#    неавторизованного доступа. Proxy может проверять доступ при каждом вызове и передавать выполнение служебному
#    объекту, если доступ разрешён.
#    3. Локальный запуск сервиса (удалённый прокси). Когда настоящий сервисный объект находится на удалённом сервере.
#    В этом случае Proxy транслирует запросы клиента в вызовы по сети в протоколе, понятном удалённому сервису.
#    4. Логирование запросов (логирующий прокси). Proxy может сохранять историю обращения клиента к сервисному объекту.
#    5. Кеширование объектов («умная» ссылка). Когда нужно кешировать результаты запросов клиентов и управлять их
#    жизненным циклом.
# Реализация:
#    1. Определить интерфейс, который бы сделал заместителя и оригинальный объект взаимозаменяемыми.
#    2. Создать класс заместителя. Он должен содержать ссылку на оригинальный объект (чаще всего создает сам
#    (в конструкторе, либо при первом вызове заменяющего метода), либо получает от клиента через конструктор)
#    3. Реализовать методы заместителя в зависимости от его предназначения. В большинстве случаев, проделав какую-то
#    полезную работу, методы заместителя должны передать запрос сервисному объекту.


from abc import ABCMeta, abstractmethod


class IFile(metaclass=ABCMeta):
    """ Интерфейс определяющий методы заместителя и оригинального объекта. """
    @abstractmethod
    def open(self):
        pass

    @abstractmethod
    def close(self):
        pass


class File(IFile):
    """ Класс оригинального объекта. """
    def __init__(self, path):
        self.path = path

    def open(self):
        print(f'Opening file: {self.path}')

    def close(self):
        print(f'Closing file: {self.path}')


class FileProxy(IFile):
    """ Класс заместителя осуществляет проверку пароля до обращения к методам оригинального объекта. """
    def __init__(self, path):
        self.path = path
        self._password = None
        self._file = None

    def open(self):
        self._password = input('Password: ')
        if self.authenticate(self._password):
            self._file = File(self.path)
            self._file.open()
            return True
        else:
            print('Wrong password!')
            return False

    @staticmethod
    def authenticate(password):
        return password == 'secret'

    def close(self):
        if self._file:
            self._file.close()
        else:
            print('File does not exist!')


if __name__ == '__main__':
    file_path = input('Path to file: ')
    file = FileProxy(file_path)
    opened = file.open()
    if opened:
        file.close()
