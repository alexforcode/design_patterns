# Главное:
#    Паттерн Chain of Responsibility позволяет передавать запросы последовательно по цепочке обработчиков. Каждый
#    последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи.
# Применение:
#    1. Когда программа должна обрабатывать разнообразные запросы несколькими способами, но заранее неизвестно, какие
#    конкретно запросы будут приходить и какие обработчики для них понадобятся.
#    2. Когда важно, чтобы обработчики выполнялись один за другим в строгом порядке.
#    3. Когда набор объектов, способных обработать запрос, должен задаваться динамически.
# Реализация:
#    1. Создать интерфейс обработчика и описать в нём основной метод обработки. Самый гибкий способ передачи данных
#    запроса в обработчик — превратить данные запроса в объект и передавать его целиком через параметры метода
#    обработчика.
#    2. Возможно стоит создать абстрактный базовый класс обработчиков, чтобы не дублировать реализацию метода получения
#    следующего обработчика во всех конкретных обработчиках.
#     - Нужно добавить поле для хранения ссылки на следующий объект цепочки. Можно устанавливать начальное значение
#     этого поля через конструктор, что сделает объекты обработчиков неизменяемыми. Если же программа предполагает
#     динамическую перестройку цепочек, то нужно добавить и сеттер для поля.
#     - Базовый метод обработки должен перенаправлять запрос следующему объекту, проверив его наличие. Это позволяет
#     полностью скрыть поле-ссылку от подклассов, дав им возможность передавать запросы дальше по цепи, обращаясь к
#     родительской реализации метода.
#    3. Создать классы конкретных обработчиков и реализовать в них методы обработки запросов. При получении запроса
#    каждый обработчик должен решить может ли он обработать запрос и следует ли передать запрос следующему обработчику.
#    4. Клиент может собирать цепочку обработчиков самостоятельно, опираясь на свою бизнес-логику, либо получать уже
#    готовые цепочки. В последнем случае цепочки собираются фабричными объектами, опираясь на конфигурацию приложения
#    или параметры окружения.
#    5. Клиент может посылать запросы любому обработчику в цепи, а не только первому. Запрос будет передаваться по
#    цепочке до тех пор, пока какой-то обработчик не откажется передавать его дальше, либо когда будет достигнут конец
#    цепи.
#    6. Клиент должен знать о динамической природе цепочки и быть готов к таким случаям: цепочка может состоять из
#    единственного объекта; запросы могут не достигать конца цепи; запросы могут достигать конца, оставаясь
#    необработанными.


from abc import ABCMeta, abstractmethod


class IParser(metaclass=ABCMeta):
    """ Интерфейс обработчика """
    @abstractmethod
    def set_next(self, parser):
        pass

    @abstractmethod
    def parse(self, file):
        pass


class DefaultParser(IParser):
    """ Базовый класс обработчика """
    def __init__(self):
        self._next_parser = None

    def set_next(self, parser):
        self._next_parser = parser
        # возврат обработчика для связи типа: json_parser.set_next(xml_parser).set_next(csv_parser)
        return parser

    @staticmethod
    def can_parse(file, ext):
        if file:
            extension = file.lower().split('.')[-1]
            if extension == ext:
                return True
        return False

    def parse(self, file):
        if self._next_parser:
            return self._next_parser.parse(file)
        return f'Unable to find parser to file: {file}'


class JSONParser(DefaultParser):
    """ Конкретный обработчик """
    def parse(self, file):
        if self.can_parse(file, 'json'):
            return f'JSON parser is parsing {file}...'
        else:
            return super().parse(file)


class XMLParser(DefaultParser):
    """ Конкретный обработчик """
    def parse(self, file):
        if self.can_parse(file, 'xml'):
            return f'XML parser is parsing {file}...'
        else:
            return super().parse(file)


class CSVParser(DefaultParser):
    """ Конкретный обработчик """
    def parse(self, file):
        if self.can_parse(file, 'csv'):
            return f'CSV parser is parsing {file}...'
        else:
            return super().parse(file)


if __name__ == '__main__':
    json_parser = JSONParser()
    xml_parser = XMLParser()
    csv_parser = CSVParser()

    json_parser.set_next(xml_parser).set_next(csv_parser)

    for file in ['file.xml', 'file.txt', 'file.csv', 'file.json']:
        result = json_parser.parse(file)
        print(result)
